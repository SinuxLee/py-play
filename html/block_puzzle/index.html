<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>方块拼图游戏</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }

    .game-container {
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 600px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    h1 {
      font-size: 28px;
      color: #333;
    }

    .score-board {
      text-align: right;
    }

    .score {
      font-size: 24px;
      font-weight: bold;
      color: #667eea;
    }

    .combo {
      font-size: 16px;
      color: #f59e0b;
      font-weight: bold;
      margin-top: 5px;
    }

    #gameCanvas {
      display: block;
      margin: 0 auto 20px;
      cursor: pointer;
      background: #f3f4f6;
      border-radius: 10px;
    }

    .blocks-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
      min-height: 100px;
    }

    .block-preview {
      background: #f3f4f6;
      padding: 15px;
      border-radius: 10px;
      cursor: move;
      transition: all 0.2s;
    }

    .block-preview:hover {
      background: #e5e7eb;
      transform: scale(1.05);
    }

    .block-preview.selected {
      background: #ddd6fe;
      box-shadow: 0 0 0 3px #8b5cf6;
      transform: scale(1.1);
    }

    .block-preview.dragging {
      opacity: 0.5;
    }

    .controls {
      text-align: center;
    }

    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 30px;
      font-size: 16px;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover {
      background: #5568d3;
    }

    .hint {
      text-align: center;
      color: #6b7280;
      margin-bottom: 15px;
      font-size: 14px;
    }

    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .game-over.show {
      display: flex;
    }

    .game-over-content {
      background: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      animation: slideIn 0.3s;
    }

    @keyframes slideIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .gem-icon {
      display: inline-block;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      border-radius: 50%;
      margin: 0 2px;
      position: relative;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .gem-icon::before {
      content: '💎';
      position: absolute;
      top: -2px;
      left: 0;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="game-container">
    <div class="header">
      <h1>💎 方块拼图</h1>
      <div class="score-board">
        <div class="score">分数: <span id="score">0</span></div>
        <div class="combo" id="combo" style="display:none;">连击 x<span id="comboCount">0</span> 🔥</div>
      </div>
    </div>

    <canvas id="gameCanvas" width="450" height="450"></canvas>

    <div class="hint" id="hint">拖拽方块到网格或点击选择</div>

    <div class="blocks-container" id="blocksContainer"></div>

    <div class="controls">
      <button onclick="resetGame()">重新开始</button>
    </div>
  </div>

  <div class="game-over" id="gameOver">
    <div class="game-over-content">
      <h2 style="font-size: 32px; margin-bottom: 20px;">🎮 游戏结束</h2>
      <p style="font-size: 20px; color: #667eea; margin-bottom: 30px;">
        最终分数: <span id="finalScore">0</span>
      </p>
      <button onclick="resetGame()">再来一局</button>
    </div>
  </div>

  <script>
    // 游戏配置
    const GRID_SIZE = 9;
    const CELL_SIZE = 45;
    const CELL_GAP = 5;
    const GEM_PROBABILITY = 0.15; // 宝石出现概率

    // 方块形状定义
    const BLOCK_SHAPES = [
      [[1]],
      [[1, 1]],
      [[1], [1]],
      [[1, 1, 1]],
      [[1], [1], [1]],
      [[1, 1], [1, 1]],
      [[1, 1, 1], [1, 0, 0]],
      [[1, 1, 1], [0, 0, 1]],
      [[1, 0], [1, 1]],
      [[0, 1], [1, 1]],
      [[1, 1], [0, 1]],
      [[1, 1, 1, 1]],
      [[1], [1], [1], [1]],
      [[1, 1, 1], [0, 1, 0]],
      [[1, 1, 1], [1, 1, 1]]
    ];

    const COLORS = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A',
      '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
      '#F8B4D9', '#A8E6CF', '#FFD3B6', '#FFAAA5'
    ];

    // 游戏状态
    let canvas, ctx;
    let grid = [];
    let blocks = [];
    let selectedBlock = null;
    let draggingBlock = null;
    let score = 0;
    let combo = 0;
    let hoverPos = null;
    let gameOver = false;

    // 初始化
    function init() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');

      // 初始化网格
      grid = Array(GRID_SIZE).fill(null).map(() =>
        Array(GRID_SIZE).fill(null).map(() => ({ color: null, hasGem: false }))
      );

      blocks = generateBlocks();
      score = 0;
      combo = 0;
      gameOver = false;

      updateScore();
      updateCombo();
      renderBlocks();
      draw();

      setupEventListeners();
    }

    // 生成随机方块
    function generateBlocks() {
      return [0, 1, 2].map(() => {
        const shape = BLOCK_SHAPES[Math.floor(Math.random() * BLOCK_SHAPES.length)];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        const gems = shape.map(row =>
          row.map(cell => cell === 1 && Math.random() < GEM_PROBABILITY)
        );
        return {
          shape,
          color,
          gems,
          id: Math.random()
        };
      });
    }

    // 绘制游戏画面
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 绘制网格
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          const x = j * CELL_SIZE;
          const y = i * CELL_SIZE;

          // 绘制单元格
          ctx.fillStyle = grid[i][j].color || '#ffffff';
          ctx.fillRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);

          // 绘制边框
          ctx.strokeStyle = '#d1d5db';
          ctx.lineWidth = 2;
          ctx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);

          // 绘制宝石
          if (grid[i][j].hasGem) {
            drawGem(x + CELL_SIZE / 2, y + CELL_SIZE / 2);
          }

          // 绘制悬停预览
          if (hoverPos && (selectedBlock || draggingBlock)) {
            const block = selectedBlock || draggingBlock;
            if (canPlaceBlock(block, hoverPos.row, hoverPos.col)) {
              for (let bi = 0; bi < block.shape.length; bi++) {
                for (let bj = 0; bj < block.shape[bi].length; bj++) {
                  if (block.shape[bi][bj] === 1 &&
                    hoverPos.row + bi === i &&
                    hoverPos.col + j === j) {
                    ctx.fillStyle = block.color + '80';
                    ctx.fillRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                  }
                }
              }
            }
          }
        }
      }
    }

    // 绘制宝石
    function drawGem(x, y) {
      const size = 12;
      ctx.save();
      ctx.translate(x, y);

      // 宝石外圈
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        const px = Math.cos(angle) * size;
        const py = Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();

      const gradient = ctx.createRadialGradient(0, -size / 3, 0, 0, 0, size);
      gradient.addColorStop(0, '#fef3c7');
      gradient.addColorStop(0.5, '#fbbf24');
      gradient.addColorStop(1, '#f59e0b');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.strokeStyle = '#d97706';
      ctx.lineWidth = 2;
      ctx.stroke();

      // 高光
      ctx.beginPath();
      ctx.arc(-size / 4, -size / 4, size / 4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.fill();

      ctx.restore();
    }

    // 检查是否可以放置
    function canPlaceBlock(block, row, col) {
      for (let i = 0; i < block.shape.length; i++) {
        for (let j = 0; j < block.shape[i].length; j++) {
          if (block.shape[i][j] === 1) {
            const r = row + i;
            const c = col + j;
            if (r >= GRID_SIZE || c >= GRID_SIZE || grid[r][c].color !== null) {
              return false;
            }
          }
        }
      }
      return true;
    }

    // 放置方块
    function placeBlock(block, row, col) {
      if (!canPlaceBlock(block, row, col)) return false;

      let gemsPlaced = 0;
      for (let i = 0; i < block.shape.length; i++) {
        for (let j = 0; j < block.shape[i].length; j++) {
          if (block.shape[i][j] === 1) {
            grid[row + i][col + j].color = block.color;
            if (block.gems[i][j]) {
              grid[row + i][col + j].hasGem = true;
              gemsPlaced++;
            }
          }
        }
      }

      // 移除使用的方块
      blocks = blocks.filter(b => b.id !== block.id);

      // 清除完整的行和列
      setTimeout(() => clearLines(), 100);

      return true;
    }

    // 清除完整的行和列
    function clearLines() {
      let rowsToClear = [];
      let colsToClear = [];
      let gemsCollected = 0;

      // 检查行
      for (let i = 0; i < GRID_SIZE; i++) {
        if (grid[i].every(cell => cell.color !== null)) {
          rowsToClear.push(i);
          gemsCollected += grid[i].filter(cell => cell.hasGem).length;
        }
      }

      // 检查列
      for (let j = 0; j < GRID_SIZE; j++) {
        if (grid.every(row => row[j].color !== null)) {
          colsToClear.push(j);
          gemsCollected += grid.filter(row => row[j].hasGem).length;
        }
      }

      const linesCleared = rowsToClear.length + colsToClear.length;

      if (linesCleared > 0) {
        // 清除行
        rowsToClear.forEach(i => {
          for (let j = 0; j < GRID_SIZE; j++) {
            grid[i][j] = { color: null, hasGem: false };
          }
        });

        // 清除列
        colsToClear.forEach(j => {
          for (let i = 0; i < GRID_SIZE; i++) {
            grid[i][j] = { color: null, hasGem: false };
          }
        });

        // 计算分数
        let baseScore = linesCleared * 10;
        let gemBonus = gemsCollected * 5;

        // 连击加成
        if (linesCleared >= 2) {
          combo++;
          baseScore += combo * 10;
          showComboEffect();
        } else {
          combo = 0;
        }

        score += baseScore + gemBonus;
        updateScore();
        updateCombo();

        draw();
      } else {
        combo = 0;
        updateCombo();
      }

      // 生成新方块
      if (blocks.length === 0) {
        blocks = generateBlocks();
        renderBlocks();

        setTimeout(() => checkGameOver(), 100);
      } else {
        renderBlocks();
      }
    }

    // 显示连击特效
    function showComboEffect() {
      const comboEl = document.getElementById('combo');
      comboEl.style.display = 'block';
      comboEl.style.animation = 'none';
      setTimeout(() => {
        comboEl.style.animation = 'pulse 0.5s';
      }, 10);
    }

    // 检查游戏结束
    function checkGameOver() {
      for (const block of blocks) {
        for (let i = 0; i < GRID_SIZE; i++) {
          for (let j = 0; j < GRID_SIZE; j++) {
            if (canPlaceBlock(block, i, j)) {
              return;
            }
          }
        }
      }

      gameOver = true;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').classList.add('show');
    }

    // 更新分数显示
    function updateScore() {
      document.getElementById('score').textContent = score;
    }

    // 更新连击显示
    function updateCombo() {
      const comboEl = document.getElementById('combo');
      if (combo > 0) {
        comboEl.style.display = 'block';
        document.getElementById('comboCount').textContent = combo;
      } else {
        comboEl.style.display = 'none';
      }
    }

    // 渲染方块预览
    function renderBlocks() {
      const container = document.getElementById('blocksContainer');
      container.innerHTML = '';

      blocks.forEach(function (block) {
        const div = document.createElement('div');
        div.className = 'block-preview';
        div.draggable = true;
        div.id = 'block-' + block.id;

        const blockCanvas = document.createElement('canvas');
        const maxSize = Math.max(block.shape.length, block.shape[0].length);
        blockCanvas.width = maxSize * 30;
        blockCanvas.height = maxSize * 30;
        const blockCtx = blockCanvas.getContext('2d');

        for (let i = 0; i < block.shape.length; i++) {
          for (let j = 0; j < block.shape[i].length; j++) {
            if (block.shape[i][j] === 1) {
              blockCtx.fillStyle = block.color;
              blockCtx.fillRect(j * 30 + 2, i * 30 + 2, 26, 26);
              blockCtx.strokeStyle = '#d1d5db';
              blockCtx.lineWidth = 2;
              blockCtx.strokeRect(j * 30 + 2, i * 30 + 2, 26, 26);

              if (block.gems[i][j]) {
                drawGemOnBlockPreview(blockCtx, j * 30 + 15, i * 30 + 15);
              }
            }
          }
        }

        div.appendChild(blockCanvas);
        container.appendChild(div);

        // 拖拽事件
        div.addEventListener('dragstart', function (e) {
          draggingBlock = block;
          selectedBlock = block;
          div.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
        });

        div.addEventListener('dragend', function () {
          draggingBlock = null;
          selectedBlock = null;
          div.classList.remove('dragging');
          draw();
        });

        // 点击选择
        div.addEventListener('click', function () {
          document.querySelectorAll('.block-preview').forEach(function (el) {
            el.classList.remove('selected');
          });
          if (selectedBlock && selectedBlock.id === block.id) {
            selectedBlock = null;
          } else {
            selectedBlock = block;
            div.classList.add('selected');
          }
          document.getElementById('hint').textContent =
            selectedBlock ? '点击网格放置方块' : '拖拽方块到网格或点击选择';
        });
      });
    }

    // 在方块预览上绘制宝石
    function drawGemOnBlockPreview(ctx, x, y) {
      const size = 8;
      ctx.save();
      ctx.translate(x, y);

      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        const px = Math.cos(angle) * size;
        const py = Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();

      ctx.fillStyle = '#fbbf24';
      ctx.fill();
      ctx.strokeStyle = '#d97706';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      ctx.restore();
    }

    // 设置事件监听
    function setupEventListeners() {
      canvas.addEventListener('mousemove', function (e) {
        if (!selectedBlock && !draggingBlock) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);

        if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
          hoverPos = { row: row, col: col };
          draw();
        }
      });

      canvas.addEventListener('mouseleave', function () {
        hoverPos = null;
        draw();
      });

      canvas.addEventListener('click', function (e) {
        if (!selectedBlock || gameOver) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);

        if (placeBlock(selectedBlock, row, col)) {
          selectedBlock = null;
          hoverPos = null;
          document.querySelectorAll('.block-preview').forEach(function (el) {
            el.classList.remove('selected');
          });
          document.getElementById('hint').textContent = '拖拽方块到网格或点击选择';
          draw();
        }
      });

      canvas.addEventListener('dragover', function (e) {
        e.preventDefault();
        if (!draggingBlock) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);

        if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
          hoverPos = { row: row, col: col };
          draw();
        }
      });

      canvas.addEventListener('drop', function (e) {
        e.preventDefault();
        if (!draggingBlock || !hoverPos) return;

        if (placeBlock(draggingBlock, hoverPos.row, hoverPos.col)) {
          draggingBlock = null;
          selectedBlock = null;
          hoverPos = null;
          draw();
        }
      });
    }

    // 重置游戏
    function resetGame() {
      document.getElementById('gameOver').classList.remove('show');
      init();
    }

    // 添加脉冲动画
    const style = document.createElement('style');
    style.textContent = `
      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.2); }
      }
    `;
    document.head.appendChild(style);

    // 启动游戏
    init();
  </script>
</body>

</html>