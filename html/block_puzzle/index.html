<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ–¹å—æ‹¼å›¾æ¸¸æˆ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }

    .game-container {
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 600px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    h1 {
      font-size: 28px;
      color: #333;
    }

    .score-board {
      text-align: right;
    }

    .score {
      font-size: 24px;
      font-weight: bold;
      color: #667eea;
    }

    .combo {
      font-size: 16px;
      color: #f59e0b;
      font-weight: bold;
      margin-top: 5px;
    }

    #gameCanvas {
      display: block;
      margin: 0 auto 20px;
      cursor: pointer;
      background: #f3f4f6;
      border-radius: 10px;
    }

    .blocks-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
      min-height: 100px;
    }

    .block-preview {
      background: #f3f4f6;
      padding: 15px;
      border-radius: 10px;
      cursor: move;
      transition: all 0.2s;
    }

    .block-preview:hover {
      background: #e5e7eb;
      transform: scale(1.05);
    }

    .block-preview.selected {
      background: #ddd6fe;
      box-shadow: 0 0 0 3px #8b5cf6;
      transform: scale(1.1);
    }

    .block-preview.dragging {
      opacity: 0.5;
    }

    .controls {
      text-align: center;
    }

    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 30px;
      font-size: 16px;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s;
    }

    button:hover {
      background: #5568d3;
    }

    .hint {
      text-align: center;
      color: #6b7280;
      margin-bottom: 15px;
      font-size: 14px;
    }

    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .game-over.show {
      display: flex;
    }

    .game-over-content {
      background: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      animation: slideIn 0.3s;
    }

    @keyframes slideIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .gem-icon {
      display: inline-block;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      border-radius: 50%;
      margin: 0 2px;
      position: relative;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .gem-icon::before {
      content: 'ğŸ’';
      position: absolute;
      top: -2px;
      left: 0;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="game-container">
    <div class="header">
      <h1>ğŸ’ æ–¹å—æ‹¼å›¾</h1>
      <div class="score-board">
        <div class="score">åˆ†æ•°: <span id="score">0</span></div>
        <div class="combo" id="combo" style="display:none;">è¿å‡» x<span id="comboCount">0</span> ğŸ”¥</div>
      </div>
    </div>

    <canvas id="gameCanvas" width="450" height="450"></canvas>

    <div class="hint" id="hint">æ‹–æ‹½æ–¹å—åˆ°ç½‘æ ¼æˆ–ç‚¹å‡»é€‰æ‹©</div>

    <div class="blocks-container" id="blocksContainer"></div>

    <div class="controls">
      <button onclick="resetGame()">é‡æ–°å¼€å§‹</button>
    </div>
  </div>

  <div class="game-over" id="gameOver">
    <div class="game-over-content">
      <h2 style="font-size: 32px; margin-bottom: 20px;">ğŸ® æ¸¸æˆç»“æŸ</h2>
      <p style="font-size: 20px; color: #667eea; margin-bottom: 30px;">
        æœ€ç»ˆåˆ†æ•°: <span id="finalScore">0</span>
      </p>
      <button onclick="resetGame()">å†æ¥ä¸€å±€</button>
    </div>
  </div>

  <script>
    // æ¸¸æˆé…ç½®
    const GRID_SIZE = 9;
    const CELL_SIZE = 45;
    const CELL_GAP = 5;
    const GEM_PROBABILITY = 0.15; // å®çŸ³å‡ºç°æ¦‚ç‡

    // æ–¹å—å½¢çŠ¶å®šä¹‰
    const BLOCK_SHAPES = [
      [[1]],
      [[1, 1]],
      [[1], [1]],
      [[1, 1, 1]],
      [[1], [1], [1]],
      [[1, 1], [1, 1]],
      [[1, 1, 1], [1, 0, 0]],
      [[1, 1, 1], [0, 0, 1]],
      [[1, 0], [1, 1]],
      [[0, 1], [1, 1]],
      [[1, 1], [0, 1]],
      [[1, 1, 1, 1]],
      [[1], [1], [1], [1]],
      [[1, 1, 1], [0, 1, 0]],
      [[1, 1, 1], [1, 1, 1]]
    ];

    const COLORS = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A',
      '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2',
      '#F8B4D9', '#A8E6CF', '#FFD3B6', '#FFAAA5'
    ];

    // æ¸¸æˆçŠ¶æ€
    let canvas, ctx;
    let grid = [];
    let blocks = [];
    let selectedBlock = null;
    let draggingBlock = null;
    let score = 0;
    let combo = 0;
    let hoverPos = null;
    let gameOver = false;

    // åˆå§‹åŒ–
    function init() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');

      // åˆå§‹åŒ–ç½‘æ ¼
      grid = Array(GRID_SIZE).fill(null).map(() =>
        Array(GRID_SIZE).fill(null).map(() => ({ color: null, hasGem: false }))
      );

      blocks = generateBlocks();
      score = 0;
      combo = 0;
      gameOver = false;

      updateScore();
      updateCombo();
      renderBlocks();
      draw();

      setupEventListeners();
    }

    // ç”Ÿæˆéšæœºæ–¹å—
    function generateBlocks() {
      return [0, 1, 2].map(() => {
        const shape = BLOCK_SHAPES[Math.floor(Math.random() * BLOCK_SHAPES.length)];
        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
        const gems = shape.map(row =>
          row.map(cell => cell === 1 && Math.random() < GEM_PROBABILITY)
        );
        return {
          shape,
          color,
          gems,
          id: Math.random()
        };
      });
    }

    // ç»˜åˆ¶æ¸¸æˆç”»é¢
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ç»˜åˆ¶ç½‘æ ¼
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          const x = j * CELL_SIZE;
          const y = i * CELL_SIZE;

          // ç»˜åˆ¶å•å…ƒæ ¼
          ctx.fillStyle = grid[i][j].color || '#ffffff';
          ctx.fillRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);

          // ç»˜åˆ¶è¾¹æ¡†
          ctx.strokeStyle = '#d1d5db';
          ctx.lineWidth = 2;
          ctx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);

          // ç»˜åˆ¶å®çŸ³
          if (grid[i][j].hasGem) {
            drawGem(x + CELL_SIZE / 2, y + CELL_SIZE / 2);
          }

          // ç»˜åˆ¶æ‚¬åœé¢„è§ˆ
          if (hoverPos && (selectedBlock || draggingBlock)) {
            const block = selectedBlock || draggingBlock;
            if (canPlaceBlock(block, hoverPos.row, hoverPos.col)) {
              for (let bi = 0; bi < block.shape.length; bi++) {
                for (let bj = 0; bj < block.shape[bi].length; bj++) {
                  if (block.shape[bi][bj] === 1 &&
                    hoverPos.row + bi === i &&
                    hoverPos.col + j === j) {
                    ctx.fillStyle = block.color + '80';
                    ctx.fillRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                    ctx.strokeStyle = '#8b5cf6';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                  }
                }
              }
            }
          }
        }
      }
    }

    // ç»˜åˆ¶å®çŸ³
    function drawGem(x, y) {
      const size = 12;
      ctx.save();
      ctx.translate(x, y);

      // å®çŸ³å¤–åœˆ
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        const px = Math.cos(angle) * size;
        const py = Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();

      const gradient = ctx.createRadialGradient(0, -size / 3, 0, 0, 0, size);
      gradient.addColorStop(0, '#fef3c7');
      gradient.addColorStop(0.5, '#fbbf24');
      gradient.addColorStop(1, '#f59e0b');
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.strokeStyle = '#d97706';
      ctx.lineWidth = 2;
      ctx.stroke();

      // é«˜å…‰
      ctx.beginPath();
      ctx.arc(-size / 4, -size / 4, size / 4, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.fill();

      ctx.restore();
    }

    // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”¾ç½®
    function canPlaceBlock(block, row, col) {
      for (let i = 0; i < block.shape.length; i++) {
        for (let j = 0; j < block.shape[i].length; j++) {
          if (block.shape[i][j] === 1) {
            const r = row + i;
            const c = col + j;
            if (r >= GRID_SIZE || c >= GRID_SIZE || grid[r][c].color !== null) {
              return false;
            }
          }
        }
      }
      return true;
    }

    // æ”¾ç½®æ–¹å—
    function placeBlock(block, row, col) {
      if (!canPlaceBlock(block, row, col)) return false;

      let gemsPlaced = 0;
      for (let i = 0; i < block.shape.length; i++) {
        for (let j = 0; j < block.shape[i].length; j++) {
          if (block.shape[i][j] === 1) {
            grid[row + i][col + j].color = block.color;
            if (block.gems[i][j]) {
              grid[row + i][col + j].hasGem = true;
              gemsPlaced++;
            }
          }
        }
      }

      // ç§»é™¤ä½¿ç”¨çš„æ–¹å—
      blocks = blocks.filter(b => b.id !== block.id);

      // æ¸…é™¤å®Œæ•´çš„è¡Œå’Œåˆ—
      setTimeout(() => clearLines(), 100);

      return true;
    }

    // æ¸…é™¤å®Œæ•´çš„è¡Œå’Œåˆ—
    function clearLines() {
      let rowsToClear = [];
      let colsToClear = [];
      let gemsCollected = 0;

      // æ£€æŸ¥è¡Œ
      for (let i = 0; i < GRID_SIZE; i++) {
        if (grid[i].every(cell => cell.color !== null)) {
          rowsToClear.push(i);
          gemsCollected += grid[i].filter(cell => cell.hasGem).length;
        }
      }

      // æ£€æŸ¥åˆ—
      for (let j = 0; j < GRID_SIZE; j++) {
        if (grid.every(row => row[j].color !== null)) {
          colsToClear.push(j);
          gemsCollected += grid.filter(row => row[j].hasGem).length;
        }
      }

      const linesCleared = rowsToClear.length + colsToClear.length;

      if (linesCleared > 0) {
        // æ¸…é™¤è¡Œ
        rowsToClear.forEach(i => {
          for (let j = 0; j < GRID_SIZE; j++) {
            grid[i][j] = { color: null, hasGem: false };
          }
        });

        // æ¸…é™¤åˆ—
        colsToClear.forEach(j => {
          for (let i = 0; i < GRID_SIZE; i++) {
            grid[i][j] = { color: null, hasGem: false };
          }
        });

        // è®¡ç®—åˆ†æ•°
        let baseScore = linesCleared * 10;
        let gemBonus = gemsCollected * 5;

        // è¿å‡»åŠ æˆ
        if (linesCleared >= 2) {
          combo++;
          baseScore += combo * 10;
          showComboEffect();
        } else {
          combo = 0;
        }

        score += baseScore + gemBonus;
        updateScore();
        updateCombo();

        draw();
      } else {
        combo = 0;
        updateCombo();
      }

      // ç”Ÿæˆæ–°æ–¹å—
      if (blocks.length === 0) {
        blocks = generateBlocks();
        renderBlocks();

        setTimeout(() => checkGameOver(), 100);
      } else {
        renderBlocks();
      }
    }

    // æ˜¾ç¤ºè¿å‡»ç‰¹æ•ˆ
    function showComboEffect() {
      const comboEl = document.getElementById('combo');
      comboEl.style.display = 'block';
      comboEl.style.animation = 'none';
      setTimeout(() => {
        comboEl.style.animation = 'pulse 0.5s';
      }, 10);
    }

    // æ£€æŸ¥æ¸¸æˆç»“æŸ
    function checkGameOver() {
      for (const block of blocks) {
        for (let i = 0; i < GRID_SIZE; i++) {
          for (let j = 0; j < GRID_SIZE; j++) {
            if (canPlaceBlock(block, i, j)) {
              return;
            }
          }
        }
      }

      gameOver = true;
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').classList.add('show');
    }

    // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
    function updateScore() {
      document.getElementById('score').textContent = score;
    }

    // æ›´æ–°è¿å‡»æ˜¾ç¤º
    function updateCombo() {
      const comboEl = document.getElementById('combo');
      if (combo > 0) {
        comboEl.style.display = 'block';
        document.getElementById('comboCount').textContent = combo;
      } else {
        comboEl.style.display = 'none';
      }
    }

    // æ¸²æŸ“æ–¹å—é¢„è§ˆ
    function renderBlocks() {
      const container = document.getElementById('blocksContainer');
      container.innerHTML = '';

      blocks.forEach(function (block) {
        const div = document.createElement('div');
        div.className = 'block-preview';
        div.draggable = true;
        div.id = 'block-' + block.id;

        const blockCanvas = document.createElement('canvas');
        const maxSize = Math.max(block.shape.length, block.shape[0].length);
        blockCanvas.width = maxSize * 30;
        blockCanvas.height = maxSize * 30;
        const blockCtx = blockCanvas.getContext('2d');

        for (let i = 0; i < block.shape.length; i++) {
          for (let j = 0; j < block.shape[i].length; j++) {
            if (block.shape[i][j] === 1) {
              blockCtx.fillStyle = block.color;
              blockCtx.fillRect(j * 30 + 2, i * 30 + 2, 26, 26);
              blockCtx.strokeStyle = '#d1d5db';
              blockCtx.lineWidth = 2;
              blockCtx.strokeRect(j * 30 + 2, i * 30 + 2, 26, 26);

              if (block.gems[i][j]) {
                drawGemOnBlockPreview(blockCtx, j * 30 + 15, i * 30 + 15);
              }
            }
          }
        }

        div.appendChild(blockCanvas);
        container.appendChild(div);

        // æ‹–æ‹½äº‹ä»¶
        div.addEventListener('dragstart', function (e) {
          draggingBlock = block;
          selectedBlock = block;
          div.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
        });

        div.addEventListener('dragend', function () {
          draggingBlock = null;
          selectedBlock = null;
          div.classList.remove('dragging');
          draw();
        });

        // ç‚¹å‡»é€‰æ‹©
        div.addEventListener('click', function () {
          document.querySelectorAll('.block-preview').forEach(function (el) {
            el.classList.remove('selected');
          });
          if (selectedBlock && selectedBlock.id === block.id) {
            selectedBlock = null;
          } else {
            selectedBlock = block;
            div.classList.add('selected');
          }
          document.getElementById('hint').textContent =
            selectedBlock ? 'ç‚¹å‡»ç½‘æ ¼æ”¾ç½®æ–¹å—' : 'æ‹–æ‹½æ–¹å—åˆ°ç½‘æ ¼æˆ–ç‚¹å‡»é€‰æ‹©';
        });
      });
    }

    // åœ¨æ–¹å—é¢„è§ˆä¸Šç»˜åˆ¶å®çŸ³
    function drawGemOnBlockPreview(ctx, x, y) {
      const size = 8;
      ctx.save();
      ctx.translate(x, y);

      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i - Math.PI / 6;
        const px = Math.cos(angle) * size;
        const py = Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();

      ctx.fillStyle = '#fbbf24';
      ctx.fill();
      ctx.strokeStyle = '#d97706';
      ctx.lineWidth = 1.5;
      ctx.stroke();

      ctx.restore();
    }

    // è®¾ç½®äº‹ä»¶ç›‘å¬
    function setupEventListeners() {
      canvas.addEventListener('mousemove', function (e) {
        if (!selectedBlock && !draggingBlock) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);

        if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
          hoverPos = { row: row, col: col };
          draw();
        }
      });

      canvas.addEventListener('mouseleave', function () {
        hoverPos = null;
        draw();
      });

      canvas.addEventListener('click', function (e) {
        if (!selectedBlock || gameOver) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);

        if (placeBlock(selectedBlock, row, col)) {
          selectedBlock = null;
          hoverPos = null;
          document.querySelectorAll('.block-preview').forEach(function (el) {
            el.classList.remove('selected');
          });
          document.getElementById('hint').textContent = 'æ‹–æ‹½æ–¹å—åˆ°ç½‘æ ¼æˆ–ç‚¹å‡»é€‰æ‹©';
          draw();
        }
      });

      canvas.addEventListener('dragover', function (e) {
        e.preventDefault();
        if (!draggingBlock) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);

        if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
          hoverPos = { row: row, col: col };
          draw();
        }
      });

      canvas.addEventListener('drop', function (e) {
        e.preventDefault();
        if (!draggingBlock || !hoverPos) return;

        if (placeBlock(draggingBlock, hoverPos.row, hoverPos.col)) {
          draggingBlock = null;
          selectedBlock = null;
          hoverPos = null;
          draw();
        }
      });
    }

    // é‡ç½®æ¸¸æˆ
    function resetGame() {
      document.getElementById('gameOver').classList.remove('show');
      init();
    }

    // æ·»åŠ è„‰å†²åŠ¨ç”»
    const style = document.createElement('style');
    style.textContent = `
      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.2); }
      }
    `;
    document.head.appendChild(style);

    // å¯åŠ¨æ¸¸æˆ
    init();
  </script>
</body>

</html>