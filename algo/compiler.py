# 1. 词法分析（Lexical Analysis）
# 将源程序分解成 词法单元（Tokens）。

# 数据结构：
# 有限状态机（Finite Automaton, DFA/NFA）
# 用于模式匹配正则表达式
# 符号表（Symbol Table）
# 存储标识符及其属性
# 常用 哈希表 或 平衡树（AVL/Red-Black Tree）

# 算法：
# 正则表达式转 NFA → DFA（Thompson 构造法 + 子集构造）
# 最小化 DFA（Hopcroft 算法）


# 2. 语法分析（Parsing）
# 把词法单元组合成 语法树 或 抽象语法树（AST）。

# 数据结构：
# 栈（Stack）
# 用于 LR/LALR 语法分析
# 抽象语法树（AST, Tree）
# 存储语法结构

# 算法：
# 自顶向下解析（LL 解析）
# 递归下降法
# 自底向上解析（LR 解析）
# LR(0), SLR(1), LALR(1) 算法
# 需要构造 DFA 状态机 表示项目集
# FIRST / FOLLOW 集计算
# 基于集合运算
# 预测分析表构造


# 3. 语义分析（Semantic Analysis）
# 检查类型、作用域等语义规则。

# 数据结构：
# 符号表（Symbol Table）
# 支持 嵌套作用域 → 栈或者哈希表 + 栈
# 抽象语法树（AST）
# 传递类型信息或符号属性
# 依赖图（Graph）
# 处理变量依赖、类型推导

# 算法：

# 类型检查算法
# 作用域链管理
# 入栈/出栈操作管理当前作用域


# 4. 中间代码生成（Intermediate Code Generation）
# 把 AST 转换成 三地址码、四元式、SSA 等中间表示。

# 数据结构：
# 抽象语法树（AST） / 控制流图（CFG, Graph）
# 表示语句的执行顺序
# 符号表 / 临时变量表
# 队列 / 栈
# 处理表达式生成后缀形式或中间代码

# 算法：
# 树遍历算法（先序/后序）生成三地址码
# 寄存器分配
# 基于图着色算法（Graph Coloring）
# 常量折叠 / 子表达式公共子表达式消除（CSE）

# 5. 优化（Optimization）
# 对中间代码或目标代码进行性能优化。

# 数据结构：
# 控制流图（CFG）
# 节点：基本块
# 边：执行流
# 数据流分析表 / 集合（Set）
# 活跃变量分析、到达定义、可用表达式
# 优先队列 / 栈
# 用于局部优化或指令调度

# 算法：
# 数据流分析算法（迭代求解）
# 图着色寄存器分配
# 循环优化
# 循环展开、循环不变代码移动
# 公共子表达式消除

# 6. 目标代码生成（Code Generation）
# 将优化后的中间代码生成汇编或机器码。

# 数据结构：
# 寄存器描述表 / 符号表
# 指令队列 / DAG（有向无环图）
# 用于表达式树优化
# 栈 / 栈帧结构
# 保存局部变量、参数、返回地址

# 算法：
# 表达式树生成汇编指令
# 指令选择算法
# 寄存器分配（图着色）
# 代码调度 / 指令重排
